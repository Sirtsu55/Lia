#version 450

layout(local_size_x = 1, local_size_y = 1) in;
layout(set = 0, binding = 0, rgba16f) uniform image2D outTex;
layout(set = 0, binding = 1) buffer Objects
{
	vec3 SphereLocations;
};

layout(set = 0, binding = 1, std140) uniform UN
{
	vec4 color;
	vec2 size;
//	vec4 Origin;
//	vec4 UpVector;
//	vec4 RightVector;

};

float IntersectSphere(vec3 rayDir, vec3 sphere, vec3 origin)
{
	vec3 oToc = origin - sphere;
	float a = dot(rayDir, rayDir);
	float b = 2 * dot(rayDir, oToc);
	float c = dot(oToc, oToc) - 1.0;
	float disc = b*b - 4*a*c;

	if(disc > 0)
	{
		return (-b - sqrt(disc)) / (2*a);
	}
	else
	{
		return -0.0;
	}
	
}

float max3 (vec3 v) {
  return max (max (v.x, v.y), v.z);
}

float min3 (vec3 v) {
  return min (min (v.x, v.y), v.z);
}


bool slabs(vec3 origin, vec3 center, vec3 invRaydir) 
{
	vec3 p0 = center+0.5;
	vec3 p1 = center-0.5;
  vec3 t0 = (p0 - origin.xyz) * invRaydir;
  vec3 t1 = (p1 - origin.xyz) * invRaydir;
  vec3 tmin = min(t0,t1), tmax = max(t0,t1);
  return max3(tmin) <= min3(tmax);
}

void main()
{
    ivec2 pos = ivec2( gl_GlobalInvocationID.xy );
	const vec2 pixelCenter = vec2(gl_GlobalInvocationID.xy ) + vec2(0.5f);
	float aspectRatio = size.x / size.y;

	vec2 UV = (-1.0 + 2.0 * pixelCenter.xy / size) * vec2(size.x/size.y, 1.0);
	
	vec3 bg;
	vec3 origin = vec3(0) ;
	
	//Rotate ray dir with rotation matrix for rotation
	vec3 rayDir = vec3(UV, -1.0);

	//vec2 di = IntersectVoxel(rayDir, vec3(0.0, 0.0, 10.0), origin);

	if(slabs(origin, vec3(0.0, 0.0, -10.0), 1/rayDir))
	{
		bg = vec3(1.0);
	}
	else
	{
		float gradient = normalize(UV.y);
		bg = mix(vec3(1.0f), color.rgb, gradient);
	}

	imageStore(outTex, ivec2(gl_GlobalInvocationID.xy), vec4(bg,1.0));
}