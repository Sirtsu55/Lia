#version 460

layout(local_size_x = 1, local_size_y = 1) in;
layout(set = 0, binding = 0, rgba16f) uniform image2D outTex;
layout(set = 0, binding = 2, std430) buffer Objects
{
	vec4 VoxelLocations[];
};

layout(set = 0, binding = 1, std140) uniform UN
{
	vec4 color;
	vec2 size;
//	vec4 Origin;
//	vec4 UpVector;
//	vec4 RightVector;

};

float max3 (vec3 v) {
  return max (max (v.x, v.y), v.z);
}

float min3 (vec3 v) {
  return min (min (v.x, v.y), v.z);
}


vec4 slabs(vec3 origin, vec3 center, vec3 rayDir) 
{
	vec3 p0 = center+0.5;
	vec3 p1 = center-0.5;
	vec3 t0 = (p0 - origin.xyz) / rayDir;
	vec3 t1 = (p1 - origin.xyz) / rayDir;
	vec3 tmin = min(t0,t1), tmax = max(t0,t1);

	vec2 t = vec2(max3(tmin), min3(tmax));

	vec3 normal = -sign(rayDir)*step(tmin.yzx,tmin.xyz)*step(tmin.zxy,tmin.xyz);

	return t.x <= t.y ? vec4(normal, t.x) : vec4(-1.0);
}

void main()
{
    ivec2 pos = ivec2( gl_GlobalInvocationID.xy );
	const vec2 pixelCenter = vec2(gl_GlobalInvocationID.xy ) + vec2(0.5f);
	float aspectRatio = size.x / size.y;

	vec2 UV = (-1.0 + 2.0 * pixelCenter.xy / size) * vec2(size.x/size.y, 1.0);
	
	vec3 bg;
	vec3 origin = vec3(0, 0, 0) ;
	
	//TODO: Rotate ray dir with rotation matrix for rotation
	vec3 rayDir = vec3(UV, -1.0);
	bool hit = false;
	for(int i = 0; i < VoxelLocations.length(); i++)
	{
		vec4 rayHit = slabs(origin, VoxelLocations[i].xyz, rayDir);
		if(rayHit.w >= 0.0)
		{
			bg = vec3(i/25.0);
			hit = true;
		}


	}
	if(!hit)
	{
		float gradient = normalize(UV.y);
		bg = mix(vec3(1.0f), color.rgb, gradient);
	}
	imageStore(outTex, ivec2(gl_GlobalInvocationID.xy), vec4(bg,1.0));
}