#version 450

layout(local_size_x = 1, local_size_y = 1) in;
layout(set = 0, binding = 0, rgba16f) uniform image2D outTex;
layout(set = 0, binding = 1) buffer Objects
{
	vec3 SphereLocations;
};

layout(set = 0, binding = 1, std140) uniform UN
{
	vec4 color;
	vec2 size;
//	vec4 Origin;
//	vec4 UpVector;
//	vec4 RightVector;

};

float max3 (vec3 v) {
  return max (max (v.x, v.y), v.z);
}

float min3 (vec3 v) {
  return min (min (v.x, v.y), v.z);
}


vec4 slabs(vec3 origin, vec3 center, vec3 rayDir) 
{
	vec3 p0 = center+2;
	vec3 p1 = center-2;
	vec3 t0 = (p0 - origin.xyz) / rayDir;
	vec3 t1 = (p1 - origin.xyz) / rayDir;
	vec3 tmin = min(t0,t1), tmax = max(t0,t1);

	vec2 t = vec2(max3(tmin), min3(tmax));

	vec3 normal = -sign(rayDir)*step(tmin.yzx,tmin.xyz)*step(tmin.zxy,tmin.xyz);

	return t.x <= t.y ? vec4(normal, t.x) : vec4(-1.0);
}

void main()
{
    ivec2 pos = ivec2( gl_GlobalInvocationID.xy );
	const vec2 pixelCenter = vec2(gl_GlobalInvocationID.xy ) + vec2(0.5f);
	float aspectRatio = size.x / size.y;

	vec2 UV = (-1.0 + 2.0 * pixelCenter.xy / size) * vec2(size.x/size.y, 1.0);
	
	vec3 bg;
	vec3 origin = vec3(-3, 3.0, 0) ;
	
	//Rotate ray dir with rotation matrix for rotation
	vec3 rayDir = vec3(UV, -1.0);

	//vec2 di = IntersectVoxel(rayDir, vec3(0.0, 0.0, 10.0), origin);
	vec4 rayHit = slabs(origin, vec3(0.0, 0.0, -10), rayDir);

	if(rayHit.w >= 0.0)
	{
		bg = vec3(rayHit.xyz);
	}
	else
	{
		float gradient = normalize(UV.y);
		bg = mix(vec3(1.0f), color.rgb, gradient);
	}

	imageStore(outTex, ivec2(gl_GlobalInvocationID.xy), vec4(bg,1.0));
}